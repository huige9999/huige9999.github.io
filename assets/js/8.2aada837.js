(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{438:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm1.75b91f97.png"},439:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm2.786c5bba.png"},440:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm3.fc59099e.png"},441:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm4.4f5f562a.png"},442:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm5.6fa34d20.png"},443:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm6.81c255d1.png"},444:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm7.9f0c280c.png"},445:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm8.1897c331.png"},446:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm9.3a85081b.png"},447:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm10.1dba047c.png"},448:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm11.0ce1b68f.png"},449:function(s,n,t){s.exports=t.p+"assets/img/webAlgorithm12.29d96d60.png"},492:function(s,n,t){"use strict";t.r(n);var a=t(2),e=Object(a.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"_1-什么是图的最小生成树问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是图的最小生成树问题"}},[s._v("#")]),s._v(" 1. 什么是图的最小生成树问题？")]),s._v(" "),n("p",[s._v("拿村庄修路来举例子：希望所有的村庄都联通，所需要的最小花费是多少？\n"),n("img",{attrs:{src:t(438),alt:"村庄修路示意图"}})]),s._v(" "),n("h3",{attrs:{id:"图的最小生成树怎么理解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图的最小生成树怎么理解"}},[s._v("#")]),s._v(" 图的最小生成树怎么理解？")]),s._v(" "),n("ul",[n("li",[s._v("树是图的特殊情况(有向无环图)")]),s._v(" "),n("li",[s._v("要想花费最少，就没必要每个村庄都各自直接联通(即：上图可以去掉一些边)")])]),s._v(" "),n("p",[n("strong",[s._v("问题转换为：如何对上图连线进行删减使得最终的花费最少？")]),s._v(" "),n("img",{attrs:{src:t(439),alt:"村庄修路示意图"}})]),s._v(" "),n("h2",{attrs:{id:"_2-为什么要解决图的最小生成树问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么要解决图的最小生成树问题"}},[s._v("#")]),s._v(" 2. 为什么要解决图的最小生成树问题？")]),s._v(" "),n("p",[s._v("上图的节点如果特别多，靠人力就很难算出最小花费，所以需要算法来帮助我们计算。")]),s._v(" "),n("h2",{attrs:{id:"_3-如何解决图的最小生成树问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何解决图的最小生成树问题"}},[s._v("#")]),s._v(" 3. 如何解决图的最小生成树问题?")]),s._v(" "),n("ul",[n("li",[s._v("普利姆算法(加点法)")]),s._v(" "),n("li",[s._v("克鲁斯卡尔算法(加边法)")])]),s._v(" "),n("h2",{attrs:{id:"_4-普利姆算法的思路"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-普利姆算法的思路"}},[s._v("#")]),s._v(" 4. 普利姆算法的思路")]),s._v(" "),n("p",[n("img",{attrs:{src:t(440),alt:"村庄修路示意图"}})]),s._v(" "),n("ol",[n("li",[s._v("随便选一个点D作为起点，看D的连线哪个最便宜，就把它连上去。\n"),n("img",{attrs:{src:t(441),alt:"村庄修路示意图"}})])]),s._v(" "),n("p",[n("img",{attrs:{src:t(442),alt:"村庄修路示意图"}})]),s._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[s._v("再把C,D看成一个整体，再看哪个连线最便宜，就把它连上去。\n"),n("img",{attrs:{src:t(443),alt:"村庄修路示意图"}})])]),s._v(" "),n("li",[n("p",[s._v("再把B,C,D看成一个整体，再看哪个连线最便宜，就把它连上去。\n"),n("img",{attrs:{src:t(444),alt:"村庄修路示意图"}})])])]),s._v(" "),n("p",[n("img",{attrs:{src:t(445),alt:"村庄修路示意图"}})]),s._v(" "),n("h3",{attrs:{id:"_4-1-小结感悟"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-小结感悟"}},[s._v("#")]),s._v(" 4.1 小结感悟")]),s._v(" "),n("ul",[n("li",[s._v("随便选一个点，以该点为起点找最便宜的连线")]),s._v(" "),n("li",[s._v("已连接的多个点当成一个整体重复上面的过程，不过要注意的是：已经联通的点就不要再连了")])]),s._v(" "),n("h3",{attrs:{id:"_4-2-算法描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-算法描述"}},[s._v("#")]),s._v(" 4.2 算法描述")]),s._v(" "),n("ol",[n("li",[s._v("任选一个点作为起点")]),s._v(" "),n("li",[s._v("找到以当前选中点为起点路径最短的边")]),s._v(" "),n("li",[s._v("如果这个边的另一端没有被联通进来，那么就连起来!")]),s._v(" "),n("li",[s._v("如果这个边的另一端已经被联通了,则看倒数第二短的边")]),s._v(" "),n("li",[s._v("重复2-4步，直到所有点都被联通")])]),s._v(" "),n("h2",{attrs:{id:"_5-普利姆算法的代码实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-普利姆算法的代码实现"}},[s._v("#")]),s._v(" 5. 普利姆算法的代码实现")]),s._v(" "),n("h3",{attrs:{id:"_5-1-图的表示方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-图的表示方法"}},[s._v("#")]),s._v(" 5.1 图的表示方法")]),s._v(" "),n("p",[s._v("两个要素：点集合、边集合\n"),n("img",{attrs:{src:t(446),alt:"村庄修路示意图"}}),s._v(" "),n("img",{attrs:{src:t(447),alt:"村庄修路示意图"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('const max = 10000;\nconst pointSet = ["A", "B", "C", "D", "E"];\n\nconst distance = [\n  [0, 9, 7, max, max],\n  [9, 0, 8, 6, max],\n  [7, 8, 0, 5, max],\n  [max, 6, 5, 0, 7],\n  [max, max, max, 7, 0],\n];\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("h3",{attrs:{id:"_5-2-代码实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-代码实现"}},[s._v("#")]),s._v(" 5.2 代码实现")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('/**\n * 普利姆算法的实现\n */\n\nconst max = 10000;\nconst pointSet = [];\n\n// 边集 记录点与点之间的距离\nconst distance = [\n  [0, 9, 7, max, max],\n  [9, 0, 8, 6, max],\n  [7, 8, 0, 5, max],\n  [max, 6, 5, 0, 7],\n  [max, max, max, 7, 0],\n];\n\n/**\n * 创建图的节点\n */\nfunction Node(value) {\n    this.value = value;\n    this.neighbors = [];\n}\n\n// 创建点集中的节点\nconst a = new Node("A");\nconst b = new Node("B");\nconst c = new Node("C");\nconst d = new Node("D");\nconst e = new Node("E");\npointSet.push(a, b, c, d, e);\n\n\n/**\n * 获取当前这个点在distance表格中的第几行\n */\nfunction getIndex(str) {\n  for(let i = 0;i < pointSet.length;i++) {\n    if(pointSet[i].value === str) {\n        return i\n    }\n  }\n  return -1;\n}\n\n\n/**\n * 根据选中节点获取最小代价的边所连接的节点\n * allPoints 点集\n * distance 边集\n * nowPointSet 当前已经选择的节点集合\n */\nfunction getMinDisNode(pointSet, distance, nowPointSet) {\n   let fromNode = null; // 线段的起点\n   let toNode = null; // 线段的终点\n   let minDis = max; // 最小距离\n   // 根据选中的节点为起点，依次判断连接其他的点的距离的值是多少\n   for (let i = 0; i < nowPointSet.length; i++) {\n     const nowPointIndex = getIndex(nowPointSet[i].value); // 当前点在disance表格中的第几行\n      for(let j = 0; j < distance[nowPointIndex].length;j++) { // 遍历distance这一行的所有节点\n        const thisNode = pointSet[j];\n        if(nowPointSet.indexOf(thisNode) === -1 && distance[nowPointIndex][j] < minDis) {\n            // 进入此if说明当前点还没有被联通 并且距离是目前最短的\n            fromNode = nowPointSet[i];\n            toNode = thisNode;\n            minDis = distance[nowPointIndex][j];\n        }\n      }\n   }\n   // 最外层循环走完之后，会找到作为起点的节点组的最小距离的边对应的终点节点\n   // 连接节点\n   fromNode.neighbors.push(toNode);\n   toNode.neighbors.push(fromNode);\n   return toNode;\n}\n\n\n/**\n * @param {*} pointSet 点集\n * @param {*} distance 边集\n * @param {*} start 起始点\n */\nfunction prim(pointSet, distance, start) {\n  const nowPointSet = []; // 存放已经选择的节点\n  nowPointSet.push(start);\n  // 获取最小代码的边\n  while(true) {\n    const minDisNode = getMinDisNode(pointSet, distance, nowPointSet);\n    // 将获取到的最小距离点加入到节点组中\n    nowPointSet.push(minDisNode);\n    // 如果节点组的长度等于点集的长度，说明所有节点都已经被联通\n    if(nowPointSet.length === pointSet.length) {\n        break;\n    }\n  }\n}\n\n\nprim(pointSet, distance, pointSet[2]);\n\nconsole.log(pointSet);\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br"),n("span",{staticClass:"line-number"},[s._v("55")]),n("br"),n("span",{staticClass:"line-number"},[s._v("56")]),n("br"),n("span",{staticClass:"line-number"},[s._v("57")]),n("br"),n("span",{staticClass:"line-number"},[s._v("58")]),n("br"),n("span",{staticClass:"line-number"},[s._v("59")]),n("br"),n("span",{staticClass:"line-number"},[s._v("60")]),n("br"),n("span",{staticClass:"line-number"},[s._v("61")]),n("br"),n("span",{staticClass:"line-number"},[s._v("62")]),n("br"),n("span",{staticClass:"line-number"},[s._v("63")]),n("br"),n("span",{staticClass:"line-number"},[s._v("64")]),n("br"),n("span",{staticClass:"line-number"},[s._v("65")]),n("br"),n("span",{staticClass:"line-number"},[s._v("66")]),n("br"),n("span",{staticClass:"line-number"},[s._v("67")]),n("br"),n("span",{staticClass:"line-number"},[s._v("68")]),n("br"),n("span",{staticClass:"line-number"},[s._v("69")]),n("br"),n("span",{staticClass:"line-number"},[s._v("70")]),n("br"),n("span",{staticClass:"line-number"},[s._v("71")]),n("br"),n("span",{staticClass:"line-number"},[s._v("72")]),n("br"),n("span",{staticClass:"line-number"},[s._v("73")]),n("br"),n("span",{staticClass:"line-number"},[s._v("74")]),n("br"),n("span",{staticClass:"line-number"},[s._v("75")]),n("br"),n("span",{staticClass:"line-number"},[s._v("76")]),n("br"),n("span",{staticClass:"line-number"},[s._v("77")]),n("br"),n("span",{staticClass:"line-number"},[s._v("78")]),n("br"),n("span",{staticClass:"line-number"},[s._v("79")]),n("br"),n("span",{staticClass:"line-number"},[s._v("80")]),n("br"),n("span",{staticClass:"line-number"},[s._v("81")]),n("br"),n("span",{staticClass:"line-number"},[s._v("82")]),n("br"),n("span",{staticClass:"line-number"},[s._v("83")]),n("br"),n("span",{staticClass:"line-number"},[s._v("84")]),n("br"),n("span",{staticClass:"line-number"},[s._v("85")]),n("br"),n("span",{staticClass:"line-number"},[s._v("86")]),n("br"),n("span",{staticClass:"line-number"},[s._v("87")]),n("br"),n("span",{staticClass:"line-number"},[s._v("88")]),n("br"),n("span",{staticClass:"line-number"},[s._v("89")]),n("br"),n("span",{staticClass:"line-number"},[s._v("90")]),n("br"),n("span",{staticClass:"line-number"},[s._v("91")]),n("br"),n("span",{staticClass:"line-number"},[s._v("92")]),n("br"),n("span",{staticClass:"line-number"},[s._v("93")]),n("br"),n("span",{staticClass:"line-number"},[s._v("94")]),n("br"),n("span",{staticClass:"line-number"},[s._v("95")]),n("br"),n("span",{staticClass:"line-number"},[s._v("96")]),n("br"),n("span",{staticClass:"line-number"},[s._v("97")]),n("br"),n("span",{staticClass:"line-number"},[s._v("98")]),n("br"),n("span",{staticClass:"line-number"},[s._v("99")]),n("br"),n("span",{staticClass:"line-number"},[s._v("100")]),n("br"),n("span",{staticClass:"line-number"},[s._v("101")]),n("br"),n("span",{staticClass:"line-number"},[s._v("102")]),n("br")])]),n("h3",{attrs:{id:"_5-3-代码小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-代码小结"}},[s._v("#")]),s._v(" 5.3 代码小结")]),s._v(" "),n("p",[n("strong",[s._v("主干函数:")])]),s._v(" "),n("p",[s._v("参数：图和起始点\n"),n("img",{attrs:{src:t(448),alt:"图片"}})]),s._v(" "),n("p",[s._v("逻辑简化:")]),s._v(" "),n("ol",[n("li",[s._v("定义起始点组")]),s._v(" "),n("li",[s._v("不断地找最小代价点加入起始点组，直到所有点都被联通(即：起始点组的长度等于点集的长度)")])]),s._v(" "),n("p",[n("strong",[s._v("难点：如何找到最小代价的点")])]),s._v(" "),n("p",[s._v("参数：图、起始点组\n"),n("img",{attrs:{src:t(449),alt:"图片"}})]),s._v(" "),n("p",[s._v("逻辑简化：")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("被比较的对象：起始点组中的每一个点")])]),s._v(" "),n("li",[n("p",[s._v("比较的对象：对应图中的点")])]),s._v(" "),n("li",[n("p",[s._v("定义起始节点、终点节点、最小距离(用于记录每次比较的最优结果)")])]),s._v(" "),n("li",[n("p",[s._v("双层for循环：遍历比较【起点组的每个点】和【对应图中的每个点】\n如果有最优解则更新最小距离、起始节点、终点节点")])]),s._v(" "),n("li",[n("p",[s._v("最优解：两点的距离更新 && 【比较对象的点】不在【被比较对象所在的点集】中")])])])])}),[],!1,null,null,null);n.default=e.exports}}]);